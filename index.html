<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My test page</title>
</head>
<style>
    #container {
        display: grid;
        grid-template-columns: repeat(10, 50px);
        grid-template-rows: repeat(10, 50px);
        gap: 1px;
    }

    .yellow {
        animation-name: yellowAnimation;
        animation-duration: 0.5s;
    }

    .green {
        animation-name: greenAnimation;
        animation-duration: 0.5s;
    }

    @keyframes yellowAnimation {
        from {
            background-color: yellow;
        }

        to {
            background-color: white;
        }
    }

    @keyframes greenAnimation {
        from {
            background-color: lightgreen;
        }

        to {
            background-color: white;
        }
    }

    #container>div {
        background-color: white;
        border: solid 1px lightgray;
        text-align: center;
        /* iOS Safari */
        -webkit-touch-callout: none;
        /* Safari */
        -webkit-user-select: none;
        /* Konqueror HTML */
        -khtml-user-select: none;
        /* Firefox */
        -moz-user-select: none;
        /* Internet Explorer/Edge */
        -ms-user-select: none;
        /* Non-prefixed version, currently
        supported by Chrome and Opera */
        user-select: none;
    }
</style>

<body>
    <div id='container'>
    </div>
    <button onclick='generate()'>
        Clear
    </button>
</body>
<script>

    const size = 10;
    const sequenceNumber = 5
    var map = [];

    function render() {
        let container = document.getElementById('container');
        console.log('rendering');
        for (var r = 0; r < map.length; r++) {
            for (var c = 0; c < map[r].length; c++) {
                let cell = map[r][c];

                if (cell.element.dataset.toclean == "true") {
                    cleanCell(cell);
                }
                cell.element.innerText = cell.value;
            }
        }
    }

    function generate() {
        let container = document.getElementById('container');
        container.innerHTML = '';

        for (var r = 0; r < size; r++) {
            map[r] = [];
            for (var c = 0; c < size; c++) {
                let t = document.createElement('div');
                t.setAttribute('data-row', r);
                t.setAttribute('data-column', c);
                t.onclick = raise;
                map[r][c] = { element: t, value: null };
                container.appendChild(map[r][c].element);
            }
        }
        render();
    }

    function raise(sender) {
        console.log('raised by:', sender.target.dataset.row, sender.target.dataset.column);
        let r = Number(sender.target.dataset.row);
        let c = Number(sender.target.dataset.column);
        let timehandler;

        for (var ri = 0; ri < map.length; ri++) {
            map[ri][c].value += 1;

            let isFibo = isFibonacci(map[ri][c].value);

            map[ri][c].element.setAttribute('data-isfibo', isFibo);
            map[ri][c].element.setAttribute('data-pos', (isFibo ? positionAtFibonacci(map[ri][c].value) : null));

            colorFlash(map[ri][c].element, false);
            // window.clearTimeout(map[ri][c].element.dataset.timer);
            // map[ri][c].element.setAttribute('data-timer', colorFlash(map[ri][c].element, 'lightyellow'));
        }
        for (var ci = 0; ci < map[r].length; ci++) {
            if (ci !== c) {

                map[r][ci].value += 1;

                let isFibo = isFibonacci(map[r][ci].value);
                map[r][ci].element.setAttribute('data-isfibo', isFibo);
                map[r][ci].element.setAttribute('data-pos', (isFibo ? positionAtFibonacci(map[r][ci].value) : null));

                // window.clearTimeout(map[r][ci].element.dataset.timer);
                colorFlash(map[r][ci].element, false);
                // map[r][ci].element.setAttribute('data-timer', colorFlash(map[r][ci].element, 'lightyellow'));
            }
        }
        render();
        checker2(sender);
    }

    function checker(sender) {

        console.log('raised by:', sender.target.dataset.row, sender.target.dataset.column);

        let target = sender.target;

        for (var ri = 0; ri < map.length; ri++) {

            let counter = 0;
            let fiboSqeuence = []
            for (var ci = 0; ci < map[ri].length; ci++) {

                if (map[ri][ci].element.dataset.isfibo == "true") {

                    if (ci == 0 || fiboSqeuence.length == 0) { //first element
                        counter++;
                        fiboSqeuence.push(map[ri][ci]);
                    }
                    else if ((ci == 1 || fiboSqeuence.length == 1) &&  //second element
                        map[ri][ci - 1].element.dataset.isfibo && //prev is fibo
                        map[ri][ci].value - map[ri][ci - 1].value <= map[ri][ci - 1].value && //diff between current and prev is equal or lower then the prev
                        (isFibonacci(map[ri][ci].value - map[ri][ci - 1].value) ||
                            (map[ri][ci].value - map[ri][ci - 1].value == 0 && map[ri][ci].value == 1))) //diff between current and prev is also a fibo ([1,3] case)
                    {

                        counter++;
                        fiboSqeuence.push(map[ri][ci]);
                    }
                    else if (ci >= 2 &&
                        map[ri][ci - 1].element.dataset.isfibo == "true" &&
                        map[ri][ci - 2].element.dataset.isfibo == "true" && //the two number before are Fibonacci numbers
                        map[ri][ci - 2].value + map[ri][ci - 1].value == map[ri][ci].value) //the sum of the two before values is equal to the current
                    {

                        counter++;
                        fiboSqeuence.push(map[ri][ci]);
                    }
                    else //sequence interrupted, The current item is still Fibonacci, so we clear the counter and the array, and push the current into it.
                    {
                        fiboSqeuence = [];
                        counter = 1;
                        fiboSqeuence.push(map[ri][ci]);
                    }
                }
                else {
                    fiboSqeuence = [];
                    counter = 0;
                    // fiboSqeuence.push(map[ri][ci]);
                }
                if (counter == sequenceNumber) {
                    prepareToClean(fiboSqeuence);
                    console.log(counter);
                }
            }
        }
        render();
    }

    function checker2(sender) {

        for (var ri = 0; ri < map.length; ri++) {

            let counter = 0;
            let fiboSqeuence = []
            let gotFirst = false; //flag if we had the first element (the first #1);
            for (var ci = 0; ci < map[ri].length; ci++) {

                if (map[ri][ci].element.dataset.isfibo == "true") {
                    //first element in the sequence
                    if (fiboSqeuence.length == 0) {
                        fiboSqeuence.push(map[ri][ci]);
                        counter++;
                    }
                    else if (fiboSqeuence.length == 1 && //second element, 
                        (Number(map[ri][ci - 1].element.dataset.pos) + 1 == Number(map[ri][ci].element.dataset.pos) ||
                            Number(map[ri][ci - 1].element.dataset.pos) == 2 && Number(map[ri][ci].element.dataset.pos) == 2)) {
                        if (Number(map[ri][ci - 1].element.dataset.pos) == 2) {
                            gotFirst = true;
                        }
                        fiboSqeuence.push(map[ri][ci]);
                        counter++;
                    } else if (
                        (map[ri][ci - 1].element.dataset.pos && Number(map[ri][ci - 1].element.dataset.pos) + 1 == Number(map[ri][ci].element.dataset.pos))) {

                        fiboSqeuence.push(map[ri][ci]);
                        counter++;
                    }
                    else {
                        fiboSqeuence = [];
                        counter = 0;
                        if (gotFirst && map[ri][ci].value == 1) { //we had the 1 before, and the sequence allows 1, 1 -> so we have to re-add it;
                            fiboSqeuence.push(map[ri][ci - 1]);
                            counter++;
                        } else if (map[ri][ci].value == 1) {
                            gotFirst = false;
                        }
                        fiboSqeuence.push(map[ri][ci]);
                        counter++;
                    }
                    if (counter == sequenceNumber) {
                        prepareToClean(fiboSqeuence);
                        console.log(counter);
                    }
                }
                else {
                    gotFirst = false;
                    fiboSqeuence = [];
                    counter = 0;
                }
            }
        }
        render();
    }


    function colorFlash(element, isClean) {

        //TODO: outsource the class names
        let colorClass = isClean ? 'green' : 'yellow';
        element.classList.remove('green');
        element.classList.remove('yellow');
        element.classList.add(colorClass);
        element.style.animation = "none";
        //layout thrasing.  https://gist.github.com/paulirish/5d52fb081b3570c81e3a
        //we need this workaround to re-animate the coloring effect.
        element.offsetLeft;
        element.style.animation = null;
    }

    function prepareToClean(toCleanArray) {
        console.log('clean', toCleanArray);
        for (var i = 0; i < toCleanArray.length; i++) {
            toCleanArray[i].element.setAttribute('data-toclean', true);
        }
    }

    function cleanCell(cell) {
        cell.value = null;
        cell.element.setAttribute('data-isfibo', false);
        cell.element.setAttribute('data-toclean', false);
        colorFlash(cell.element, true);
    }

    /*TODO: clear it or refactor it.
    *I use the prev cells to check instead of recalculate the positions every time.
    *Rethink if the 1,1,2 sequence could be beasier with this or not.
    */
    function positionAtFibonacci(number) {

        if (number <= 1)
            return 2;

        let a = 0, b = 1, c = 1;
        let res = 1;

        //iterate to get the last Fibonacci number before the given
        while (c < number) {
            c = a + b;

            // res is the counter for the position in the sequence
            res++;
            a = b;
            b = c;
        }

        return res;
    }

    function isFibonacci(number) {
        if (!number)
            return false;
        //Regarding the wikipedia, a number is Fibonacci number if it is a perfect squeare 
        return isPerfectSqueare(5 * number * number + 4) || isPerfectSqueare(5 * number * number - 4);
    }
    function isPerfectSqueare(number) {
        var s = Number(Math.sqrt(number).toFixed(0))
        return (s * s === number);
    }

    generate();
</script>

</html>